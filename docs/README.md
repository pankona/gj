# 設計のメモなどを書くところ

## スプライトをクリックしたらコールバックする

### 概要

「if クリックを検知したら～」という処理をメインループに書き下していくと、クリック判定の分岐があちこちに散らばってしまう。
もうちょっと見通しを良くするために、各オブジェクトには「onClick」みたいなメソッドを持たせておき、クリックされたらその関数をコールバックするような仕組みにしておきたい。

### 設計

あらゆるものがクリック対象になるわけではないので、クリック対象はつけ外しができる必要がある。AddEventListener/RemoveEventListener のノリで実装すればよさそう。

スプライトが重なっているとき、一番手前のスプライトだけクリックを受けて後ろのスプライトには効果が及ばないようにするのが良いような気がする。JavaScript でいうところの event.preventDefault がデフォルトの振る舞いであるようなイメージ。
これをやるためには、複数のスプライトが AddEventListener されていたとして、誰が一番手前にいるのかというのを処理する必要がある。z-index のようなものをスプライトには持たせておき、これで AddEventListener されたものをあらかじめソートしておく (新規に AddEventListener されたときにソートする) のが良いような気がしている。

クリックイベントが発生したとき、AddEventListener されたオブジェクト全てに対して以下の処理を行う。

- クリック位置が、自身に重なっているか？
  - YES ならば当該オブジェクトの onClick を呼び出し、ループを終了する
  - No ならば、次のオブジェクトに対する評価に移る

### 懸念など

オブジェクトの数が多くなってくるとループが長くなるので、パフォーマンスに影響するかもしれない？

- 100も200もクリック対象がある、という状況は考えにくいというか、そういう UI にしちゃいけないような気はする

## 音を出す仕組み

### 概要

何かが起きたら音を出したいことがある。効果音も BGM もある。
これも if 文で分岐しだすと見通しが悪くなるような気がしている。そもそも音とゲームロジックはなるべく分離しておきたい。

### 設計

「何かが起きる」はイベントとして表現する。pubsub じみた仕組みを導入し、イベントをサブスクライブする誰かがいるような構成にする。
「音を鳴らすやつ」はイベントを購読している。イベントを見て、対応する音を鳴らす仕組みにする。

### 懸念など

イベントは channel を用いた queue 構造で表せばいいかな？と思っているが、一時にあまりにもたくさんのイベントがつまれてしまうと、同フレームで処理しきれなくなってしまうようなことも起こるかもしれない？

## コールバックとイベントキューの扱いの違い

クリックも音を出すのも見ようによっては同じイベントであるから、どちらもコールバック (あるいはイベントキュー) の形でじっそうすればいいんじゃないか、という話があるかもしれない。

コールバックとイベントキューの違いは、「同一フレーム内で絶対に処理したいかどうか」というのがポイントであると考えている。クリックイベントはただちに実行してほしいが、音を出すとかその他のゲームロジックとやや離れたところにある処理 (いわゆるビュー) は、圧倒的に遅れることがないのであれば、ちょっと遅れて実行されても良いという発想。

プレイヤーの HP が 0 になったら、その瞬間にプレイヤーは死亡扱いにしたい。でも死亡時の音の再生であるとか、アニメーションであるとかは数フレーム遅れても差し支えないのではないか？みたいなところである (真偽不明) 。

## アニメーションの仕組み

### 概要

https://ebitengine.org/ja/examples/animation.html が大いに参考になる。だいたい以下のやり方をする。
- アニメーションセット (仮称) となる画像を用意しておく。
- image.SubImage を使って、表示する位置を次々に切り替えていく。

### 設計

- 一生ループしてほしいアニメーションと、一回ループすればよいアニメーションがあるはず。これらは切り替えられるようなオプションがあると良さそう
- アニメーションを取り入れだすと画像の量が多くなりがちかと思う。アニメーションさせたいタイミングで画像を読み込むとゲームの動作に影響が出そうなので、初期化時に必要な画像は一気に読み込んでおくってやる必要がありそう。
- これもイベントドリブンで駆動するのがいいのかもしれない。
  - アニメーションの長さはゲームロジックに関わる場合があるが、アニメーションの内容そのものはゲームロジックに関わらない。ゲームロジックとして「このアニメーションが終わってから次の処理にいく」ということをやりたいケースがありそうだが、所要時間をゲームロジックで表現し、アニメーションはそれにフィットするように作るのが良いかと思う。ロジックが主、アニメーションが従。

### 懸念など

- 素材がない

## クリックとタップは同一視する

### 概要

ウェブ上で動作するし、スマホでも操作できるゲームにしようという目論見がある。
- スマホだと基本的にタップ操作しかできない。マルチタッチや長押しもあるっちゃあるが。
- なので、シンプルに「タップだけで操作できる」というところを目指す。デバッグしやすいように、PC 上ではクリックで操作できるようにしておく。

### 設計

クリックなのかタップなのかというのは区別しなくて良いということになるので、これらは同一に扱うようにラッパーかなにかを仕込んでおこう。
あとキーボード操作とか十字キーの操作とかは登場させない操作体系にするということを念頭に置いておく。

### 懸念など

操作体系としてはシンプルで良いが、これだと足りない！っていうことになりそうな気がしないでもない。
画面上にボタンを表示して、タップで押させるというアイデアもあるかもしれない。あとドラッグ操作くらいは許容にする可能性はある？ (スマホでドラッグはどうやる？)

## package 構成

### 概要

いったん main package 一本で行く。このモジュールは将来使いまわしができそうだから別の package にしとこー、みたいのは脱稿してから考えよう。

## テストの実行

ebitengine を使ったコードに対して `go test ./...` とやると、描画に関連したエラーがいくつか出ることがある。これは ebitengine が init の中でいくらか描画関連の処理を呼び出すことが理由であるようだ。なのでテストを実行するときにはいくらかお膳立てをしておく必要がある。

詳細は github actions のテスト実行の部分を参照のこと。

## 敵の行動アルゴリズム

まず、いったん3種類くらいの敵キャラがいることを考える。それぞれ微妙に異なった特徴をもっていると想定する。
ここでは便宜的に「赤虫」「青虫」「緑虫」と呼称する。

暫定で以下のようなアルゴリズムで動くとしてみる。

- 共通動作
  - 前にすでに他の虫がいる場合、
    - その場で待機する
    - (Option) ちょっと迂回するような動きで前に進める道を探す

- 赤虫
  - 家に向かって一直線に進む。壁などにぶつかったら、ぶつかったものに対して攻撃を行う。
  - 攻撃は一定時間ごとに行う。攻撃範囲はせまい。自身の周囲ちょっとくらい。
  - 体力は少ない。
  - ただし大量に出現する。
  - 動きは速い。

- 青虫
  - 最寄りの障害物に向かって進む。障害物にぶつかったら、ぶつかったものに対して攻撃を行う。
  - 攻撃は一定時間ごとに行う。攻撃機範囲はせまい。自身の周囲ちょっとくらい (赤虫と同じ)。
  - 体力は赤虫よりもちょっと多い。
  - 赤虫より多く出現する。
  - 動きの速さは普通。

- 緑虫
  - 家に向かって一直線に進む。
  - 攻撃は一定時間ごとに行う。攻撃範囲が広い。飛び道具のようなものを放つ。
  - 攻撃範囲に任意の障害物が入ったとき、その障害物に向かって攻撃を行う。
  - 体力は青虫よりも多い。
  - 出現頻度は低い。
  - 動きは遅い。

## プレイヤーによる敵への攻撃

### 概要

プレイヤーが敵に対して攻撃を行うことができる。攻撃の方法は、クリックした位置を中心に一定範囲内に攻撃を行うというものとする。
いくらかクールタイムを設けて、連続して攻撃を行えないようにする。何ウェーブか過ぎたあとにレベルアップさせることで、攻撃範囲や攻撃力を上げることができるようにするのもありかも。

### 設計

クリックによって攻撃を発動するということと、各建物やユニットをクリックすることで情報を表示するという操作が競合していることに留意する必要がある。
ここでは、ウェーブ中はクリックした位置に攻撃を発動すると共に、クリックした位置に建物やユニットが存在する場合は情報表示も行うという仕様にする。
ウェーブ中でないときは、クリックした位置に建物やユニットが存在する場合は情報表示を行う。攻撃は行わない。

- (Option) 攻撃のクールタイムも画面上のどこかに表示したい
- (Option) 攻撃力の情報もどこかで確認できるようにしたい

攻撃のための OnClick をどこで受けるか
- 素朴にやると、各ユニットの onClick で攻撃のためのロジックを実装することになるが、疎な設計でなく、拡張がつらくなりそうな気がする
- ここでは、「攻撃のためのクリックを受け取るオブジェクト」として、透明なペインを画面全体に敷き詰めるやり方でやってみようと思う
  - 透明なペインは、画面全体に敷き詰める。そいつが Clickable を実装しているとする
  - ZIndex がそこそこ高い (少なくとも画面上の建物やユニットよりは高い)
  - info を表示したいのであれば、「クリックを貫通」させる必要があるかもしれない

